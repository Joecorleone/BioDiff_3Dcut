import numpy as np
import math
from matplotlib import pyplot as plt
import time
from mpl_toolkits.mplot3d import Axes3D
import base64
import string
import os
import copy


def module_exists(module_name):
    try:
        __import__(module_name)
    except ImportError:
        return False
    else:
        return True

"""
	global values, which will probably not be altered
"""
imageplateHeight=450#in mm
imageplateRadius=199#in mm
state = 1
#sample is assumed in center position



#maybe also create a singleScan class, to read all the values
class singleScanClass(object):
	
	
	def __init__(self,x_monochromator,y_monochromator,z_monochromator,tilt_monochromator,theta_monochromator,
			twotheta_selectorarm,d_diaphragm1,d_diaphragm2,twotheta_detectorunit,
			z_neutronimageplate,z_CCDcamera,twotheta_CCDcamera,z_CCD,
			z_sampletable,omega_sampletable,omega_samplestepper,x_sampletable,y_sampletable,
			attocube,
			x_samplegoniometer,y_samplegoniometer,omega_samplegoniometer,
			shutter,photo_shutter,TimeInSec,
			Mon1,Mon2,Mon3,Mon4,Mon5,imageplate,imageplateTemp,selector,image_file):
		self.x_monochromator=float(x_monochromator)
		self.y_monochromator=float(y_monochromator)
		self.z_monochromator=float(z_monochromator)
		self.tilt_monochromator=float(tilt_monochromator)
		self.theta_monochromator=float(theta_monochromator)
		self.twotheta_selectorarm=twotheta_selectorarm
		self.d_diaphragm1=d_diaphragm1
		self.d_diaphragm2=d_diaphragm2
		self.twotheta_detectorunit=twotheta_detectorunit
		self.z_neutronimageplate=z_neutronimageplate
		self.z_CCDcamera=z_CCDcamera
		self.twotheta_CCDcamera=twotheta_CCDcamera
		self.z_CCD=z_CCD
		self.z_sampletable=z_sampletable
		self.omega_sampletable=float(omega_sampletable)
		self.omega_samplestepper=omega_samplestepper
		self.x_sampletable=x_sampletable
		self.y_sampletable=y_sampletable
		self.attocube=attocube
		self.x_samplegoniometer=x_samplegoniometer
		self.y_samplegoniometer=y_samplegoniometer
		self.omega_samplegoniometer=omega_samplegoniometer
		self.shutter=shutter
		self.photo_shutter=photo_shutter
		self.TimeInSec=TimeInSec
		self.Mon1=int(Mon1)
		self.Mon2=int(Mon2)
		self.Mon3=int(Mon3)
		self.Mon4=int(Mon4)
		self.Mon5=int(Mon5)
		self.imageplate=imageplate
		self.imageplateTemp=imageplateTemp
		self.selector=selector
		self.image_file=image_file #seems to be the same for each singlescan of a scan
		
	def getMonochromator(self):
		return [self.x_monochromator,self.y_monochromator,self.z_monochromator,self.tilt_monochromator,self.theta_monochromator]
	
	def printMonochromator(self):
		print "x: %f" %self.x_monochromator
		print "y: %f" %self.y_monochromator
		print "z: %f" %self.z_monochromator
		print "tilt: %f" %self.tilt_monochromator
		print "theta: %f" %self.theta_monochromator
		
class scanConfigClass(object):
	"""Class for a scan specific scan as defined in the according config file
	"""
	
	
	def __init__(self,StartTime,ExperimentName,ScanName,ScanType,ScanCommand,SingleScans):
		"""set up the configs for a scan containig an array of SingleScans
		"""
		self.startTime=StartTime
		self.experimentName=ExperimentName,
		self.scanName=ScanName
		self.scanType=ScanType
		self.scanCommand=ScanCommand
		self.singleScans=SingleScans
		self.numberOfScans=len(SingleScans)
		
#create a Qarray where everything is saved to?
#class contains a numpy array of datapoints in Q and information of the scans
#ToDo
class setOfScans(object):
	def __init__(self,Name,Saved,Filename,Wavelength,
			Firstscan,Lastscan,Scanstep,Omegaoffset,Orientationmatrix,ShiftedImages):
		self.name 		= Name
		self.saved 		= Saved
		self.filename		= Filename
		self.wavelength		= Wavelength
		self.firstscan		= Firstscan
		self.lastscan		= Lastscan
		self.scanstep		= Scanstep
		self.omegaoffset	= Omegaoffset
		self.orientationmatrix	= Orientationmatrix
		self.shiftedImages	= ShiftedImages
	
def loadSetFile(filename):
	#print filename
	if filename.endswith('.set'):
		try:
			file=open(filename,'r')
		except IOError:
			print 'file %s not found!' %filename
			print 'Please specifiy a valid setup file, extension: ".set"'  
			return []
	else:
		try:
			file=open(filename + '.set','r')
		except IOError:
			print 'file %s not found!' %(filename+'.set')
			print 'Please specifiy a valid setup file, extension: ".set"'  
			return	[]
	filelines=file.readlines()
	
	#initialize variabls
	name = None
	filename = None
	wavelength = None
	firstscan = 0
	lastscan = -1
	scanstep = 1
	omegaoffset = 0
	orientationmatrix = np.mat([[1,0,0],[0,1,0],[0,0,1]])
	
	shiftedImages = True
	
	
	
	ListOfLoadedSets=[]
	comments=False
	notOnlyCommentsInLine=False
	scansEntered = False
	saved = False
	multiLineCommentTag="'''"
	singleLineCommentTag="#"
	for line in filelines:
		linestrip = line.strip()
		
		if multiLineCommentTag in linestrip:
			
			if comments:
				#ended at end of the line
				if linestrip.endswith(multiLineCommentTag):
					comments = False
				#ended at start or inbetween of the line
				else:
					linestrip = linestrip.split(multiLineCommentTag)[1].strip()
					comments = False
					notOnlyCommentsInLine = True				
				
			else:
				#started at start of line
				if linestrip.startswith(multiLineCommentTag):
					comments = True
				#started in between or at the end of a line
				else:
					linestrip = linestrip.split(multiLineCommentTag)[0].strip()
					comments = True
					notOnlyCommentsInLine = True
					
				
		if comments and not notOnlyCommentsInLine:
			pass
		else:
			
			if singleLineCommentTag in linestrip:
				if linestrip.startswith(singleLineCommentTag):
					notOnlyCommentsInLine = False
				else:
					linestrip = linestrip.split(singleLineCommentTag)[0].strip()
					notOnlyCommentsInLine = True
			if not singleLineCommentTag in linestrip or notOnlyCommentsInLine:	
				#print linestrip
				if linestrip=='':
					pass
				elif linestrip.startswith('+setOfScans{'):
					scansEntered = True
					saved = False
				elif linestrip.startswith('+savedSet{'):
					scansEntered = True
					saved = True
				elif linestrip.startswith('name:') and scansEntered:
					name = linestrip.replace('name:','').strip()
				elif linestrip.startswith('filename:') and scansEntered:
					filename = linestrip.replace('filename:','').strip()
				elif linestrip.startswith('wavelength:') and scansEntered:
					wavelength = float(linestrip.replace('wavelength:','').strip())
				elif linestrip.startswith('firstscan:') and scansEntered:
					firstscan = int(linestrip.replace('firstscan:','').strip())
				elif linestrip.startswith('lastscan:') and scansEntered:
					lastscan = int(linestrip.replace('lastscan:','').strip())
				elif linestrip.startswith('scanstep:') and scansEntered:
					scanstep = int(linestrip.replace('scanstep:','').strip())
				elif linestrip.startswith('omegaoffset:') and scansEntered:
					omegaoffset = float(linestrip.replace('omegaoffset:','').strip())
				elif linestrip.startswith('orientationmatrix:') and scansEntered:
					orientationmatrix = np.mat(eval(linestrip.replace('orientationmatrix:','').strip()))
				elif linestrip.startswith('shiftedImages:') and scansEntered:
					shiftedImages = linestrip.replace('shiftedImages:','').strip()
				elif linestrip.startswith('}') and scansEntered:
					ListOfLoadedSets.append(setOfScans(name,saved,filename,wavelength,
						firstscan,lastscan,scanstep,omegaoffset,orientationmatrix,shiftedImages))
					
					scansEntered = False
					#reset variables
					name = None
					saved = False
					filename = None
					wavelength = None
					firstscan = 0
					lastscan = -1
					scanstep = 1
					omegaoffset = 0.0
					orientationmatrix = np.array([[1,0,0],[0,1,0],[0,0,1]])
					shiftedImages = True
					
		
			notOnlyCommentsInLine = False
	
	print ''
	#all configs for sets from .set-file read 
	SofQArrayOfScan=[]
	
	
	for scanSet in ListOfLoadedSets:
		if scanSet.saved:
			print "loading saved sets is not yet included!"
			if len(SofQArrayOfScan)==0:
				#SofQArrayOfScan=loadedOne
				
				pass
			else:
				#hstack
				pass
			#hstack
		else:
			print "reading setofScans from %s:" %scanSet.filename
			scanConfig=readScanFile(scanSet.filename)
			
			inputarray=readFile("%s_%i.txt" %(scanConfig.singleScans[0].image_file,0))
			pixelheight=len(inputarray)
			pixelwidth=len(inputarray[0])
			wavelength = float(scanConfig.singleScans[0].selector)
			#print "wavelength:", wavelength
			kincident=2*np.pi/scanSet.wavelength#wavelength
			QstarArray=calcQstar(kincident,pixelwidth,pixelheight)
			#print "Qzrange: %.2f to %.2f" %(QstarArray[2].min(),QstarArray[2].max())
			
			scanIntervalOk = True
			scanStepOk = True
			
			if scanSet.firstscan>=0 and scanSet.firstscan<=len(scanConfig.singleScans)-1:
				firstScan = scanSet.firstscan
			elif scanSet.firstscan <= -1:
				firstScan = len(scanConfig.singleScans)+1+scanSet.firstscan
			else:
				print 'Invalid firstscan entered for set of scans %s!' %scanSet.name
				scanIntervalOk = False			
			
			if scanSet.lastscan>=0 and scanSet.lastscan<=len(scanConfig.singleScans)-1:
				lastScan = scanSet.lastscan + 1
			elif scanSet.lastscan <= -1:
				lastScan = len(scanConfig.singleScans)+1+scanSet.lastscan
			else:
				print 'Invalid lastscan entered for set of scans %s!' %scanSet.name
				scanIntervalOk = False
				
			if firstScan>lastScan:
				print 'Empty interval of scans for set of scans %s!' %scanSet.name
				scanIntervalOk = False
				
			if scanSet.scanstep <= 0:
				print 'Choosen scanstep for det of scans %s is invalid!' %scanSet.name
				scanStepOk=False
				
				
			
			if not scanIntervalOk:
				print 'Set of scans %s was skipped, due to the choosen interval!' %scanSet.name
				
			elif not scanStepOk:
				print 'Set of scans %s was skipped, due to the choosen scanstep!' %scanSet.name
				
			else:
				for i,singleScan in enumerate(scanConfig.singleScans[firstScan:lastScan:scanSet.scanstep]):
					omega=singleScan.omega_sampletable+scanSet.omegaoffset
					imagefileTxt="%s_%i.txt" %(singleScan.image_file,i) 
					IntensArray=readFile(imagefileTxt)
		
					SofQArrayOfScan.append(calcQ(kincident,pixelwidth,pixelheight,omega,QstarArray,IntensArray,orientationmatrix,shiftedImages))
					print "\tmeasurement %i of %i, omega: %.2f" %(i+1, math.floor((lastScan-firstScan)*1.0/scanSet.scanstep),omega)#len(scanConfig.singleScans), omega)#scanConfig.numberOfScans)	
				print ''
			
	return SofQArrayOfScan		
	
	
	
def readScanFile(filename):
	file=open(filename,'r')
	filelines=file.readlines()
	StartTimeString="Scan started at  "
	ExperimentNameString="Experiment name: "
	ScanNameString="Scan name: "
	ScanTypeString="Scan type: "
	ScanCommanString="#\t"
	#SingleScansString=""
	SingleScans=[]
	
	header=True
	scans=False
	for line in filelines:
		if (header and not scans):			
			if line.find(StartTimeString)>-1:
				StartTime=line.split(StartTimeString)[1]
			elif line.find(ExperimentNameString)>-1:
				ExperimentName=line.split(ExperimentNameString)[1]
			elif line.find(ScanNameString)>-1:
				ScanName=line.split(ScanNameString)[1]
			elif line.find(ScanTypeString)>-1:
				ScanType=line.split(ScanTypeString)[1]
			elif line.find(ScanCommanString)>-1:
				ScanCommand=line.split(ScanCommanString)[1]
				header=False
		
		elif (not header and not scans):
			if line.startswith("#x_monochromator[1]y_monochromator[2]"):
				scans=True
				
		elif (not header and scans):
			linesplit=line.split()
			SingleScans.append(singleScanClass(linesplit[0],linesplit[1],linesplit[2],linesplit[3],linesplit[4],
			linesplit[5],linesplit[6],linesplit[7],linesplit[8],linesplit[9],
			linesplit[10],linesplit[11],linesplit[12],linesplit[13],linesplit[14],
			linesplit[15],linesplit[16],linesplit[17],linesplit[18],linesplit[19],
			linesplit[20],linesplit[21],linesplit[22],linesplit[23],linesplit[24],
			linesplit[25],linesplit[26],linesplit[27],linesplit[28],linesplit[29],
			linesplit[30],linesplit[31],linesplit[32],linesplit[33]))
				
	return scanConfigClass(StartTime,ExperimentName,ScanName,ScanType,ScanCommand,SingleScans)	# at least omega and lambda <- not correct lambda
				# lambda has to be defined manually
				# config file gives scan numbers with correct omega position

def readFile(filename):
	if module_exists('pandas'):
		import pandas
		inputarray = np.array(pandas.read_csv(filename, sep = '\t', header = None), dtype = np.uint32)
	else:
		print "Please consider installing the module 'pandas' for speed up."
		inputarray = np.loadtxt(filename, dtype = np.uint32)
	
	return inputarray#numpy array
	

	
def calcQ(kincident,pixelwidth,pixelheight,omega,QstarArray,IntensArray,orientationmatrix=np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]]),shiftedImages=True,range=[-180,180]):
	shiftpixel=174
	if shiftedImages:
		if checkForShift(pixelwidth,pixelheight,IntensArray):
			IntensArray=np.hstack((IntensArray[:,pixelwidth-shiftpixel:],IntensArray[:,:pixelwidth-shiftpixel]))
	
	omegaR=omega/180.0*np.pi	
	rotMat=np.matrix([[np.cos(omegaR),-np.sin(omegaR),0],[np.sin(omegaR),np.cos(omegaR),0],[0,0,1]])
	QstarArray=orientationmatrix*rotMat*np.matrix(QstarArray)

	#print np.ravel(IntensArray).shape,np.ravel(IntensArray)
	return (np.ravel(QstarArray[0]),np.ravel(QstarArray[1]),np.ravel(QstarArray[2]),np.ravel(IntensArray))

def checkForShift(pixelwidth,pixelheight,IntensArray):
	#additional array around coulkd be checked
	if np.array(IntensArray[pixelheight/2-10:pixelheight/2+10,pixelwidth/2-10:pixelwidth/2+10]).mean()>= IntensArray.mean():
		print "   following measurement is shifted"
		return True
	else:
		return False
	
	
def angleToQstar(kincident,phix,phiy):
	sinPhix=np.matrix(np.sin(phix))
	#sinPhixM90=np.matrix(np.sin(phix-np.pi/2.0))
	cosPhix=np.matrix(np.cos(phix))
	sinPhiy=np.matrix(np.sin(phiy))
	cosPhiy=np.matrix(np.cos(phiy))

	#part with good resolution is on right side seen from origin
	QstarX= cosPhiy.transpose() * cosPhix +1  
	QstarY= cosPhiy.transpose() * sinPhix*(-1)

	QstarZ=sinPhiy.transpose() * np.matrix(np.ones_like(np.sin(phix)))

	QstarX=np.ravel(QstarX)
	QstarY=np.ravel(QstarY)
	QstarZ=np.ravel(QstarZ)	
		
	return kincident*np.array([QstarX,QstarY,QstarZ])#


def calcQstar(kincident,pixelwidth,pixelheight,range=[-180,180]):
	
	rowpixel=np.arange(0,pixelwidth)+0.5 # insert +0.5
	columnpixel=np.arange(0,pixelheight)+0.5 # insert +0.5
	#incoming beam is phix,phiy=0
	phiy=np.arctan((pixelheight*1.0/2.0-columnpixel*1.0)/pixelheight*imageplateHeight/imageplateRadius)	
	#print  phiy/np.pi*180.0
	phix=rowpixel*1.0/pixelwidth*2*np.pi
	QstarArray=angleToQstar(kincident,phix,phiy)
	return QstarArray

'''
Binning
'''
def createHistHorizontalLayer(SofQarrayOfScan,minQx,maxQx,deltaQx,minQy,maxQy,deltaQy,minQz,maxQz): #binning necessary

	resolution=2
	#size=I/I.max()*150*scalePoints/100
	#idx=np.arange(0,len(SofQarrayOfScan[0][0])*len(SofQarrayOfScan),2060)
	
	#create grids:
	xgrid= np.arange(minQx,maxQx,deltaQx)	
	ygrid= np.arange(minQy,maxQy,deltaQy)
	extent=[minQx,maxQx,maxQy,minQy]
	
	xgridh=np.append(xgrid, 2*xgrid[-1]-xgrid[-2])
	ygridh=np.append(ygrid, 2*ygrid[-1]-ygrid[-2])

	rawidx=np.where((SofQarrayOfScan[0][2]>=minQz) & (SofQarrayOfScan[0][2]<=maxQz))
	Qx=SofQarrayOfScan[0][0][rawidx]
	Qy=SofQarrayOfScan[0][1][rawidx]
	# Qz=SofQarrayOfScan[0][2][rawidx]
	I=SofQarrayOfScan[0][3][rawidx]	
	mean=I.mean()	
	if len(SofQarrayOfScan)>1:
		for SofQarray in SofQarrayOfScan[1:]:		
			rawidx=np.where((SofQarray[2]>=minQz) & (SofQarray[2]<=maxQz))
			Qx=np.hstack((Qx,SofQarray[0][rawidx]))
			Qy=np.hstack((Qy,SofQarray[1][rawidx]))
			#Qz=np.hstack((Qz,SofQarray[2][rawidx]))
			I=np.hstack((I,SofQarray[3][rawidx]))
	Inorm=np.ones(I.shape)
	H, xedges, yedges=np.histogram2d(Qy, Qx,(ygridh,xgridh), weights=I)
	Hnorm, xedgesNorm, yedgesNorm=np.histogram2d(Qy, Qx, (ygridh,xgridh), weights=Inorm)
	idx=np.where(Hnorm!=0)
	Intensity=np.array(H)
	Intensity[idx]=H[idx]/Hnorm[idx]
	return (Intensity-mean, extent)


class grid():
	'''
	object to hold the information about the specified grid
	'''
	def __init__(self,minQx,maxQx,deltaQx,minQy,maxQy,deltaQy,minQz,maxQz,deltaQz):
		self.bins  = (int((maxQx-minQx)/float(deltaQx)),int((maxQy-minQy)/float(deltaQy)),int((maxQz-minQz)/float(deltaQz)))
		self.deltaQx = deltaQx
		self.deltaQy = deltaQy
		self.deltaQz = deltaQz
		self.range = ((minQx,maxQx),(minQy,maxQy),(minQz,maxQz))
		# Meshgrid has the middle of the histogram bin
		self.xMeshgrid, self.yMeshgrid, self.zMeshgrid  = np.meshgrid(
				np.linspace(minQy+deltaQx/2.0,maxQy+deltaQx/2.0,num=self.bins[1],endpoint=False),
				np.linspace(minQx+deltaQy/2.0,maxQx+deltaQy/2.0,num=self.bins[0],endpoint=False),
				np.linspace(minQz+deltaQz/2.0,maxQz+deltaQz/2.0,num=self.bins[2],endpoint=False))

		#self.xMeshgrid, self.yMeshgrid, self.zMeshgrid  = np.ravel(self.xMeshgrid), np.ravel(self.yMeshgrid), np.ravel(self.zMeshgrid)
		self.histIntensity, extent = np.histogramdd((np.arange(0,10),np.arange(0,10),np.arange(0,10)),bins=self.bins,range=self.range,weights = np.zeros((10)))
		# extent is the boundary of the bins
		print 'EXTENT: x:',extent[0].min(),extent[0].max(),len(extent[0]),'; y:',extent[1].min(),extent[1].max(),len(extent[1]),'; z:',extent[2].min(),extent[2].max(),len(extent[2])
		print 'HistoShape:',self.histIntensity.shape
		self.histIntensity = np.array(self.histIntensity, dtype = np.uint32)
		self.histCounting  = copy.deepcopy(self.histIntensity)
		
	def __str__(self):
		return "bins: %s, range: %s" %(str(self.bins) ,str(self.range))

	def updateHistogram(self,AddHistIntensity,AddHistCounting):
		self.histIntensity += AddHistIntensity
		self.histCounting  += AddHistCounting
		
	def getNormedIntensity(self):
		idx=np.where(self.histCounting!=0)
		Intensity=np.array(self.histIntensity)
		Intensity[idx]=self.histIntensity[idx]/self.histCounting[idx]
		return Intensity


def sortIntoGrid(Grid, QArray,Intensity):
	'''
	sorts the detector pixel in a predefined grid
	
	Keywords:
	grid -- contains the information on number of bins and overall range
	QArray -- QCoordinates for each pixel of a single detector image
	Intensity -- measured intensity for each pixel	
	'''
	median = np.median(Intensity)
	idx = np.where(Intensity>median)
	t0 = time.time()
	Intens, extentIntens =np.histogramdd((QArray[0][idx],QArray[1][idx],QArray[2][idx]),bins=Grid.bins,range=Grid.range,weights = Intensity[idx])
	t1 = time.time()
	print 'IntensHisto',t1-t0
	count , extentCount  =np.histogramdd((QArray[0][idx],QArray[1][idx],QArray[2][idx]),bins=Grid.bins,range=Grid.range)
	t2 = time.time()
	print 'CountHisto',t2-t1
	Grid.updateHistogram(Intens,count)
	t3 = time.time()
	print 'Update',t3-t2



def createCut(Grid,minQx=None,maxQx=None,minQy=None,maxQy=None,minQz=None,maxQz=None, integrationAxis = 'z'):
	"""
	create a cut in the before filled grid
	
	Keywords:
	Grid -- a grid, which has been filled with detectorpixel from several measurements
	minQx,...,maxQz -- Limits for the cut, also work as integration boundaries
	integrationAxis -- the axis which is integrated along, has be either 'x','y' or 'z'	
	"""
	possibleIntegrationAxis = ['x','y','z']
	if not integrationAxis in possibleIntegrationAxis:
		print "Specified integration axis '%s' is not valid, no cut created!" %str(integrationAxis)
		return
	else:
		if minQx is None:
			minQx = Grid.xMeshgrid.min()
		if maxQx is None:
			maxQx = Grid.xMeshgrid.max()+Grid.deltaQx
		if minQy is None:
			minQy = Grid.yMeshgrid.min()
		if maxQy is None:
			maxQy = Grid.yMeshgrid.max()+Grid.deltaQy
		if minQz is None:
			minQz = Grid.zMeshgrid.min()
		if maxQz is None:
			maxQz = Grid.zMeshgrid.max()+Grid.deltaQz
		
		print minQx,maxQx,minQy,maxQy,minQz,maxQz
		#print 'xGrid',Grid.xMeshgrid,'shape:',Grid.xMeshgrid.shape
		#print 'yGrid',Grid.yMeshgrid,'shape:',Grid.yMeshgrid.shape
		#print 'zGrid',Grid.zMeshgrid,'shape:',Grid.zMeshgrid.shape
		# original Meshgridincludes minQ but not maxQ
		
		
		#print 'nIntens',normedIntens,'shape:',normedIntens.shape
		
		
		idx = np.where((Grid.xMeshgrid >= minQx) & (Grid.xMeshgrid <= maxQx) 
			     & (Grid.yMeshgrid >= minQy) & (Grid.yMeshgrid <= maxQy) 
			     & (Grid.zMeshgrid >= minQz) & (Grid.zMeshgrid <= maxQz))
		#print len(Grid.xMeshgrid[idx]),':',Grid.xMeshgrid[idx].reshape((maxQy-minQy)/Grid.deltaQy,(maxQx-minQx)/Grid.deltaQx,(maxQz-minQz)/Grid.deltaQz)
		#print len(Grid.yMeshgrid[idx]),':',Grid.yMeshgrid[idx].reshape((maxQy-minQy)/Grid.deltaQy,(maxQx-minQx)/Grid.deltaQx,(maxQz-minQz)/Grid.deltaQz)
		#print len(Grid.zMeshgrid[idx]),':',Grid.zMeshgrid[idx].reshape((maxQy-minQy)/Grid.deltaQy,(maxQx-minQx)/Grid.deltaQx,(maxQz-minQz)/Grid.deltaQz)
		#print len(normedIntens[idx]),':', normedIntens[idx]#.reshape((maxQx-minQx)/Grid.deltaQx,(maxQy-minQy)/Grid.deltaQy,(maxQz-minQz)/Grid.deltaQz)
		#print (maxQy-minQy)/Grid.deltaQy,(maxQx-minQx)/Grid.deltaQx,(maxQz-minQz)/Grid.deltaQz, (maxQx-minQx)/Grid.deltaQx*(maxQy-minQy)/Grid.deltaQy*(maxQz-minQz)/Grid.deltaQz
		normedIntens = Grid.getNormedIntensity()
		#print Grid.xMeshgrid.shape
		#print normedIntens.shape
		normedIntens = normedIntens[idx]
		#.reshape((maxQx-minQx)/Grid.deltaQx,(maxQy-minQy)/Grid.deltaQy,(maxQz-minQz)/Grid.deltaQz)
		#print len(normedIntens),':', normedIntens.reshape((maxQx-minQx)/Grid.deltaQx,(maxQy-minQy)/Grid.deltaQy,(maxQz-minQz)/Grid.deltaQz)
		normedIntens = normedIntens.reshape((maxQy-minQy)/Grid.deltaQy,(maxQx-minQx)/Grid.deltaQx,(maxQz-minQz)/Grid.deltaQz)
		
		# TODO check if sum axis are correct for 'x' and 'y'
		if integrationAxis == 'x':
			#bins = (int((maxQy-minQy)/float(Grid.deltaQy)),int((maxQz-minQz)/float(Grid.deltaQz)))
			#return np.histogram2d((Grid.yMeshgrid[idx],Grid.zMeshgrid[idx]),bins=bins,range=((minQy,maxQy),(minQz,maxQz)),weights = normedIntens[idx])
			return (normedIntens.sum(axis=1),[minQy,maxQy,maxQz,minQz])
			
		elif integrationAxis == 'y':
			#bins = (int((maxQx-minQx)/float(Grid.deltaQx)),int((maxQz-minQz)/float(Grid.deltaQz)))
			#return np.histogram2d((Grid.xMeshgrid[idx],Grid.zMeshgrid[idx]),bins=bins,range=((minQx,maxQx),(minQz,maxQz)),weights = normedIntens[idx])
			return (normedIntens.sum(axis=0),[minQx,maxQx,maxQz,minQz])
			
		elif integrationAxis == 'z':
			#bins = (int((maxQx-minQx)/float(Grid.deltaQx)),int((maxQy-minQy)/float(Grid.deltaQy)))
			#return np.histogram2d((Grid.xMeshgrid[idx],Grid.yMeshgrid[idx]),bins=bins,range=((minQx,maxQx),(minQy,maxQy)),weights = normedIntens[idx])
			return (normedIntens.sum(axis=2),[minQx,maxQx,maxQy,minQy])

'''
Plotting read Scans
'''
def plotSingleScan(SofQarray):
	fig = plt.figure()
	fig.facecolor=1.0
	ax = fig.gca(projection='3d')
	#size=I/I.max()*150*scalePoints/100
	idx=np.arange(0,len(SofQarray[0]),250)
	I=SofQarray[3]
	color=I/I.max()
	ax.scatter(SofQarray[0][idx],SofQarray[1][idx],SofQarray[2][idx], zdir='z', label='zs=0, zdir=z', marker='o', s=2, c=color[idx], edgecolors=None)
	#ax.scatter(SofQarray[0],SofQarray[1],SofQarray[2], zdir='z', label='zs=0, zdir=z', marker='o', s=2, c=color, edgecolors=None)
	ax.legend()
	ax.facecolor='white'
	plt.show()
	
def plotMultipleScans(SofQarrayOfScan):
	fig = plt.figure()
	fig.facecolor=1.0
	ax = fig.gca(projection='3d')
	#size=I/I.max()*150*scalePoints/100
	idx=np.arange(0,len(SofQarrayOfScan[0][0])*len(SofQarrayOfScan),2060)	
	Qx=SofQarrayOfScan[0][0]
	Qy=SofQarrayOfScan[0][1]
	Qz=SofQarrayOfScan[0][2]
	I =SofQarrayOfScan[0][3]
	color=I/I.max()
	for SofQarray in SofQarrayOfScan[1:]:
		Qx=np.hstack((Qx,SofQarray[0]))
		Qy=np.hstack((Qy,SofQarray[1]))
		Qz=np.hstack((Qz,SofQarray[2]))
		I=np.hstack((I,SofQarray[3]))		
	color=I/I[idx].max()	
	ax.scatter(Qx[idx],Qy[idx],Qz[idx], zdir='z', label='zs=0, zdir=z', marker='o', s=8, c=color[idx], edgecolors='none')
	#ax.scatter(SofQarray[0],SofQarray[1],SofQarray[2], zdir='z', label='zs=0, zdir=z', marker='o', s=2, c=color, edgecolors=None)
	ax.legend()
	ax.facecolor='white'
	plt.show()
		
def twoDplot(Intensity,extent,Imin=None,Imax=None):
	if Imin is not None and Imax is not None:
		plt.imshow(Intensity, extent=extent, vmin=Imin,vmax=Imax,interpolation='nearest')
	elif Imin is not None:
		plt.imshow(Intensity, extent=extent, vmin=Imin,interpolation='nearest')
	elif Imax is not None:
		plt.imshow(Intensity, extent=extent, vmax=Imax,interpolation='nearest')
	else:
		plt.imshow(Intensity, extent=extent,interpolation='nearest')
	plt.colorbar()
	plt.show()
	

def main():
	wavelength=2.6737#in Angstroem, can be read from selector
	#possible reading resolutions: 125, 250, 500 in micrometer
	resolution=500#in micrometer
	#changes the number of pixel per picture, can also be read out
	
	#if resolution is the same for each scan you can set constResolution=True
	constResolution=True
	
	#to change initial rotation of sample
	omega_offset=-20.9
	
	
	
	#runname="test_031212_2998"
	#runname="test_031212_3076"
	runname=["test_031212_3076","test_031212_3077"]
	#user should specify the configfilename, each scan filenam is clear then
	
	"""
	Necessary assumption: all scans have the same resolution and wavelength!!!
	sort all runs by their omegavalue
	
	"""
	imagefiles = []
	omegas     = []
	
	for run in runname:
		scanConfig=readScanFile(run)
		for i,singleScan in enumerate(scanConfig.singleScans):
			imagefile = "%s_%i.txt" %(singleScan.image_file,i)
			if os.path.isfile(imagefile):
				imagefiles.append(imagefile)
				omegas.append(singleScan.omega_sampletable + omega_offset)
			else:
				print "Imagefile %s is not present in folder, will be skipped!" %(imagefile)
			
	
	omegas = np.array(omegas)
	imagefiles = np.array(imagefiles)
	wavelength = float(scanConfig.singleScans[0].selector)
	print "wavelength:", wavelength
	kincident=2*np.pi/wavelength
	
	# sort arrays after omega, necessary if several runs are combined
	idx        = np.argsort(omegas)
	omegas     = omegas[idx]
	imagefiles = imagefiles[idx]
	
	
	# Determine the QstarArray
	"""
	QstarArray is an array containing the Q coordinates corresponding to the pixels of a detector image,
	it is a prototype for all measurements, rotating the array around zAxis 
	"""
	inputarray=readFile(imagefiles[0])
	pixelheight=len(inputarray)
	pixelwidth=len(inputarray[0])
	QstarArray=calcQstar(kincident,pixelwidth,pixelheight)
	
	# only valid if crystal has c-axis parallel to rotation axis
	print "Qzrange: %.2f to %.2f" %(QstarArray[2].min(),QstarArray[2].max())
	
	# creating the grid, choosing it too large or with too small deltas will unnecessarily increse its size
	minQx, maxQx, deltaQx = -1.5,3.3,0.005
	minQy, maxQy, deltaQy = -1.0,3.5,0.005
	minQz, maxQz, deltaQz = -0.1,0.1,0.01#-1.1,1.1,0.01
	histoGrid = grid(minQx,maxQx,deltaQx,minQy,maxQy,deltaQy,minQz,maxQz,deltaQz)
	print histoGrid
	
	# putting the images into the grid
	# Qcoordinates are created by rotating the QstarArray around omega
	# Intensities will be directly sorted into the predefined grid, to save memory usage
	# therefore only one measurement set and the grid have to be kept in the memory during runtime
	# after filling the grid the user can executes cut on the grid
	
	# interpolat inbetween scans
	numInterpol = 3 #number of additional interpolation steps
	n=numInterpol+1.0
	
	
	for i, (omega, imagefile) in enumerate(zip(omegas,imagefiles)):
		startTime = time.time()
		IntensArray=readFile(imagefile)
		t1 = time.time()
		print t1-startTime
		SofQ = calcQ(kincident,pixelwidth,pixelheight,omega,QstarArray,IntensArray)
		t2 = time.time()
		print t2-t1
		sortIntoGrid(histoGrid,(SofQ[0],SofQ[1],SofQ[2]),SofQ[3])
		t3 = time.time()
		print t3-t2
		print "Measurement %i of %i with omega=%f sorted into the grid" %(i+1,len(omegas),omega)
		if numInterpol>0 and i<len(omegas)-1:
			nextScanOmega  = omegas[i+1]
			nextScanIntens = readFile(imagefiles[i+1])
			for j in range(1,int(n)):
				interPolOmega = omega*(n-j)/n + nextScanOmega * j/n
				SofQ = calcQ(kincident,pixelwidth,pixelheight,interPolOmega,QstarArray,IntensArray*(n-j)/n + nextScanIntens * j/n)
				sortIntoGrid(histoGrid,(SofQ[0],SofQ[1],SofQ[2]),SofQ[3])
				print "\tInterpolation %i of %i with omega=%f sorted into the grid" %(j,numInterpol,interPolOmega)
		
	intensMap,extent = createCut(histoGrid,minQz=-0.1,maxQz=0.1,integrationAxis = 'z')	
	while True:
		manualVmin = int(raw_input('Enter vmin: '))
		manualVmax = int(raw_input('Enter vmax: '))
		plt.imshow(intensMap,extent = extent,vmin=manualVmin,vmax=manualVmax, interpolation='nearest') #, vmin=Imin,vmax=Imax
		plt.colorbar()
		plt.show()	
	"""
	for i,run in enumerate(runname):
		
				
		
		for i,singleScan in enumerate(scanConfig.singleScans):
			omega=singleScan.omega_sampletable+omega_offset
			imagefileTxt="%s_%i.txt" %(singleScan.image_file,i) 
			#print imagefileTxt
			IntensArray=readFile(imagefileTxt)
			
			#print IntensArray
			#calc some common values
			SofQArrayOfScan.append(calcQ(kincident,pixelwidth,pixelheight,omega,QstarArray,IntensArray))
			#print SofQarray
			print "measurement %i of %i, omega: %.2f" %(i+1, len(scanConfig.singleScans), omega)#scanConfig.numberOfScans)
		

	#return SofQArrayOfScan
	"""


	
def saveArray(Array,filename):
	np.save(filename,Array)
	#TODO: also save a config holding the information of the set of scans
	
def loadArray(filename):
	#TODO: also read a config holding the information of the set of scans
	return np.load(filename)


def createOutputFile(Intensity,extent,filename,boolGPscript):
	dataoutput = open(filename + '.map', 'w')
	
	#create the grid
	xgrid=np.linspace(extent[0],extent[1],num=len(Intensity),endpoint=False)
	ygrid=np.linspace(extent[3],extent[2],num=len(Intensity[0]),endpoint=False)
	
	for i,y in enumerate(ygrid):
		for j,x in enumerate(xgrid):
			dataoutput.write("%f\t%f\t%f\n" %(x,y,Intensity[i][j]))
		dataoutput.write("\n")
			
	dataoutput.close()
	if boolGPscript:
		gnuploscript = open(filename + '.gp', 'w')
		gnuploscript.write("reset\nset encoding utf8\nset view map  \nset term png\nset output '%s.png'\nset pm3d interpolate 1,1\nset palette positive nops_allcF maxcolors 0 gamma 1.5 color model RGB\n" %(filename))
		gnuploscript.write("set palette defined ( 0 0 0 1, 0.25 0 1 1, 0.5 0 1 0, 0.75 1 1 0, 1 1 0 0 )\n set ylabel 'Q_y'\nset xlabel 'Q_x'\nset colorbox\nshow colorbox\nset cbrange [%f:%f]\nset title ''\nset size square\nset border lw 0.6\nset tics scale 0.5\n"%(Intensity.min(),Intensity.max()))
		gnuploscript.write("splot [:][:][:] '%s.map' u 1:2:($3*1) with pm3d notitle" %filename)
		gnuploscript.close()



'''
	Menu
'''
def displayMainMenu(state):
	#state = 1 nothing loaded yet
	#state = 2 data loaded, no hist
	#state = 3 data loaded, hist
	print "\n  main menu:"
	print "-------------------"
	print "  1: load new set file"
	if state>1:
		print "  2: create a histogramm from points in a horizontal layer"
	if state>2:
		print "  3: plot the current histogramm"
		print "  4: export the current histogramm"
	print "  0: exit"
	print "-------------------"

	
def menuLoadSetFile():
	global state
	#loading data loop 
	while True:
		setFileName = raw_input('Please enter a SetFile present in the directory: ')
		#print setFileName
		QArray = loadSetFile(setFileName.strip())#loadSetFile('measurementAt4K')
		if len(QArray)>0:
			break
	if state == 1:
		state = 2
	return QArray

def menuSpecifyHisto(QArray):
	global state
	while True:
		gridInQx = raw_input('Specifiy the grid in Qx ("start,end,step"): ')
		startQx,endQx,stepQx = np.array(gridInQx.split(','),dtype=float)
		if endQx>startQx and stepQx > 0:
			break
		else:
			print "Please specify a valid grid!"
	
	while True:
		gridInQy = raw_input('Specifiy the grid in Qy ("start,end,step"): ')
		startQy,endQy,stepQy = np.array(gridInQy.split(','),dtype=float)
		if endQy>startQy and stepQy > 0:
			break
		else:
			print "Please specify a valid grid!"
		
	while True:
		rangeInQz = raw_input('Specifiy the integration range in Qz ("start,end"): ')	
		startQz,endQz = np.array(rangeInQz.split(','),dtype=float)
		if endQz>startQz:
			break
		else:
			print "Please specify a valid range in Qz!"
			
	if state == 2:
		state = 3
	return createHistHorizontalLayer(QArray,startQx,endQx,stepQx,startQy,endQy,stepQy,startQz,endQz)

def menuPlotHisto(Intensity,extent):
	global state
	while True:
		rangeI = raw_input('Specifiy the range in intensitydisplayed ("Imin,Imax")\n "None" value for one of them will adjust intensity limit automatically ("None,Imax"): ')
		IMin,IMax = rangeI.strip().split(',')
		if IMin == "None":
			if IMax == "None":
				twoDplot(Intensity,extent)
				break
			else:
				twoDplot(Intensity,extent,Imax=float(IMax))
				break
		elif IMax == "None":
			twoDplot(Intensity,extent,Imin=float(IMin))
			break
		else:
			if IMax>=IMin:
				twoDplot(Intensity,extent,Imin=float(IMin),Imax=float(IMax))
				break
			else:
				print "Please specify a valid range in intensity!"
				
def menuExportHisto(Intensity,extent):
	global state
	valid_chars = "-_.()%s%s" % (string.ascii_letters, string.digits)
	while True:
		filename = raw_input('Choose a filename for the data file (without extension): ')
		#if os can create such file fine, other wise error
		filename_corrected = ''.join(c for c in filename if c in valid_chars)
		if filename_corrected == filename:
			
			while True:
				boolGPscript = raw_input('Do you wish to create a gnuplot script too? (Y/n) ').strip()
				if boolGPscript == 'y' or boolGPscript == 'Y' or boolGPscript == '':					
					
					boolGPscript = True
					break
				elif boolGPscript == 'n' or boolGPscript == 'N':
					boolGPscript = False
					break
				else:
					print "Please type 'y' or 'n'"
			
			
							
			break
		else:
			print "Please choose a valid filename, e.g. %s" %filename_corrected
			
	createOutputFile(Intensity,extent,filename_corrected,boolGPscript)


		
	
print '\n\n'
print '\t##############################'
print '\t#                            #'
print '\t#        Biodiffplot         #'
print '\t#            v0.01           #'
print '\t#                            #'
print '\t##############################'
print '\n'
	

if __name__=='__main__':
	
	main()
	
	
	#QArray = menuLoadSetFile()
	#plotting loop
	while False:
		displayMainMenu(state)
		chooseOption = raw_input('Please choose an option: ').strip()
		
		if chooseOption == '1' and state>=1:
			QArray = menuLoadSetFile()
		elif chooseOption =='2' and state>=2:
			Intensity,extent = menuSpecifyHisto(QArray)
		elif chooseOption =='3' and state>=3:
			menuPlotHisto(Intensity,extent)	
		elif chooseOption =='4' and state>=3:
			menuExportHisto(Intensity,extent)
		elif chooseOption == '0' and state>=1:
			break
		else: 
			print 'Please choose a valid option!' 
			time.sleep(1)

else:
	print 'for help execute function "help()"'

	#SofQArrayOfScan = main()
	#Intensity,extent = plotHorizontalLayer(SofQArrayOfScan,-1.5,3.0,0.005,-1.0,3.5,0.005,-0.05,0.05)
	#Intensity,extent = plotHorizontalLayer(SofQArrayOfScan,-2.0,3.5,0.01,-2.0,3.5,0.01,-0.2,0.2)
	#twoDplot(Intensity,extent,Imin=0,Imax=80)
	##
	## fuck ypixel gehen nach aussen
	##
	##
